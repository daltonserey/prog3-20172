class: center, middle
# N√∫meros Racionais
### ¬©2017 Dalton Serey, Programa√ß√£o 3, UFCG
.center[![Right-aligned image](https://i.stack.imgur.com/Mmww2.png)]
---
# n√∫mero racional

qualquer n√∫mero que pode ser expresso na forma

<script type="math/tex; mode=display">
  \frac{p}{q}, \text{ em que } p, q \in \mathbb{Z} \text { e } q \neq 0
</script>

---
# opera√ß√µes: igualdade

igualdade

<script type="math/tex; mode=display">
  \begin{aligned}
  & \frac{p}{q} = \frac{r}{s} && \text{ se e somente se } && ps = qr
  \end{aligned}
</script>

---
# opera√ß√µes: simplifica√ß√£o (ou redu√ß√£o)

- se $gcd(p, q)$ √© i gual a 1, dizemos que $p/q$ √© _irredut√≠vel_

   - e que $p / q$ √© a forma simplificada/reduzida do n√∫mero

- se $gcd(p, q) > 1$, dizemos que $p/q$ √© _redut√≠vel_

   - e que a forma simplificada/reduzida do n√∫mero √© dada por

<script type="math/tex; mode=display">
  \begin{aligned}
  & \frac{p \div d}{q \div d} && \text{ onde $d = gcd(p, q)$}
  \end{aligned}
</script>


---
# opera√ß√µes: soma e subtra√ß√£o

<br>

<script type="math/tex; mode=display">
  \frac{p}{q} + \frac{r}{s} = \frac{ps + qr}{qs} 
</script>

<br>

<script type="math/tex; mode=display">
  \frac{p}{q} - \frac{r}{s} = \frac{ps - qr}{qs} 
</script>

---
# opera√ß√µes: produto e divis√£o

<br>

<script type="math/tex; mode=display">
  \frac{p}{q} \times \frac{r}{s} = \frac{pr}{qs}
</script>

<br>

<script type="math/tex; mode=display">
  \begin{aligned}
  & \frac{p}{q} \div \frac{r}{s} = \frac{ps}{qr} && \text{ com $r \neq 0$}
  \end{aligned}
</script>

---
class: center, middle
#implementa√ß√£o
<span style="font-size: 300px">1</span>
#funcional pura
---
# representa√ß√£o de racionais

podemos representar racionais como objetos em JavaScript

```
const r1 = { num: 1, den: 2 };
const r2 = { num: 1, den: 4 };
const r3 = { num: 2, den: 3 };
const r4 = { num: 3, den: 5 };
```

<br>
--
count: false
dessa forma, contudo, expomos detalhes de implementa√ß√£o para o usu√°rio ‚òπ 

---
# representa√ß√£o abstrata de racionais

para representar de forma abstrata, usamos uma fun√ß√£o construtora

```
function racional(num, den) {
    return {num: num, den: den};
}
```

--
count: false
<br>
embora pare√ßa fazer o mesmo, permite expressar racionais assim
```
const r1 = racional(1, 2);
const r2 = racional(1, 4);
const r3 = racional(2, 3);
const r4 = racional(3, 5);
```

<br>
assim, o usu√°rio √© exposto a detalhes da implementa√ß√£o üëç 

---
# um pouco de robustez

vamos garantir que usos ‚Äúabusivos‚Äù sejam corrigidos

```
function racional(num, den) {
    return { num: Math.truc(num), den: Math.trunc(den) };
}
```

--
count: false
agora o usu√°rio n√£o consegue criar racionais impr√≥prios 
```
const r1 = racional(1, 2);
const meio = racional(1.5, 2.2); # igual a r1
```

.footnote[mais adiante, veremos como tornar _properties_ imut√°veis]
---
# igualdade

```
function iguais(r1, r2) {
    return r1.num * r2.den == r1.den * r2.num;
}
```

<br>
agora podemos fazer
```
const r1 = racional(1, 2);
const r2 = racional(1, 3);

iguais(r1, r2);                          // false
iguais(r1, racional(3, 6));              // true
iguais(r2, racional(2, 6));              // true
iguais(racional(2, 5), racional(6, 15)); // true
```

---
# simplifica√ß√£o

```
function simpl(r) {
    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);

    const dc = gcd(r.num, r.den);
    return racional(r.num / dc, r.den / dc);
}
```

<br>
agora podemos escrever
```
const r = racional(4, 8); // { num: 4, den: 8 }
const s = simpl(r);    // { num: 1, den: 2 }
iguais(r, s);             // true
```

---
# opera√ß√µes aritm√©ticas

```
function soma(r1, r2) {
    const n = r1.num * r2.den + r2.num * r1.den;
    const d = r1.den * r2.den;
    return simpl(racional(n, d));
}

function sub(r1, r2) {
    const n = r1.num * r2.den - r2.num * r1.den;
    const d = r1.den * r2.den;
    return simpl(racional(n, d));
}

function mult(r1, r2) {
    const n = r1.num * r2.num;
    const d = r1.den * r2.den;
    return simpl(racional(n, d));
}

function div(r1, r2) {
    const n = r1.num * r2.den;
    const d = r1.den * r2.num;
    return simpl(racional(n, d));
}
```

---
# toString()

√© sempre bom dispor de uma forma _string_ apropriada
```
function toString(r) {
  return `${r.num}/${r.den}`;
}
```

assim
```
const r1 = simpl(racional(5, 10));
toString(r1);                        // '1/2'
console.log(`r1 = ${toString(r1)}`); // r1 = 1/2
```

---
# aplica√ß√£o

o que a express√£o abaixo calcula?
```
// x = ((r1 + r2) x (r3 x r4)) √∑ (r3 x (r1 - r4))
const x = div(mult(soma(r1, r2), mult(r3, r4)), mult(r3, sub(r1, r4)));
```

como estender a defini√ß√£o para soma de v√°rios
```
// x = r1 + r2 + r3 + r4 + r5
const x1 = soma(soma(soma(soma(r1, r2), r3), r4), r5);
const x2 = soma(r1, soma(r2, soma(r3, soma(r4, r5))));
```
---
# c√≥digo final

https://repl.it/@daltonserey/numeros-racionais-funcional-1

---
# qualidades da solu√ß√£o üëç 

1. √© f√°cil de entender

   - por serem fun√ß√µes puras, todas as fun√ß√µes sempre que
     invocadas produzem novos valores, sem depender ou alterar de
     dados j√° presentes na mem√≥ria; a opera√ß√£o de todas as
     fun√ß√µes depende apenas dos par√¢metros e do c√≥digo;

2. pode ser usada parcialmente

   - algumas das fun√ß√µes dependem de outras (por exemplo, `soma`
     depende de `simpl` e de `racional`); contudo, n√£o h√°
     depend√™ncias entre todas elas; logo, em contextos em que
     apenas algumas sejam necess√°rias, pode-se excluir as que n√£o
     forem necess√°rias;

3. usa espa√ßo de fun√ß√µes forma eficiente

   - cada fun√ß√£o s√≥ √© criada uma √∫nica vez, sem importar a
     quantidade de n√∫meros racionais que seja necess√°rio
     manipular;

---
# defeitos da solu√ß√£o üëé

1. n√£o usa espa√ßo de n√∫meros forma eficiente ü§î

   - por serem fun√ß√µes puras, sempre que uma fun√ß√£o √© que
     invocadas produzem novos valores, sem depender ou alterar de
     dados j√° presentes na mem√≥ria; a opera√ß√£o de todas as
     fun√ß√µes depende apenas dos par√¢metros e do c√≥digo;

2. pode ser usada parcialmente

   - algumas das fun√ß√µes dependem de outras (por exemplo, `soma`
     depende de `simpl` e de `racional`); contudo, n√£o h√°
     depend√™ncias entre todas elas; logo, em contextos em que
     apenas algumas sejam necess√°rias, pode-se excluir as que n√£o
     forem necess√°rias;

3. usa espa√ßo de forma eficiente

   - cada fun√ß√£o s√≥ √© criada uma √∫nica vez, sem importar a
     quantidade de n√∫meros racionais que seja necess√°rio
     manipular;
